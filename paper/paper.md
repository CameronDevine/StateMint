---
title: 'Statum: An Application for Determining Symbolic Dynamic System Models using Linear Graph Methods'
tags:
  - system dynamics
  - calculator
  - symbolic math
  - computer algebra system
authors:
  - name: Cameron Devine
    orcid: 0000-0002-6579-111X
    affiliation: 1
  - name: Joseph L. Garbini
    affiliation: 1
  - name: Rico A. R. Picone
    orcid: 0000-0002-5091-5175
    affiliation: "2, 1"
affiliations:
  - name: University of Washington, Department of Mechanical Engineering
    index: 1
  - name: Saint Martin's University, Department of Mechanical Engineering
    index: 2
date: 26 September 2018
bibliography: paper.bib
---

# Summary

When determining the differential equation of a dynamic system using linear graph methods finding the elemental and constraint equations is the first step.
The next step is to algebraically eliminate those variables that are not state or input variables from the equations until a minimal set of differential equations remains.
During this step of manually reducing the system of equations is where students often make mistakes, leading to frustration and discouragement.
However, this algebra is not a necessary component of a strong understanding of system dynamics and can be easily automated using tools we present here.


To aid students in their learning process a program was written to symbolically determine the differential equations using the elemental and constraint equations as input.
This program allows students to focus on the process of creating a dynamic system model without worrying about algebraic mistakes.
This allows the student to focus on course content which is new and unique.

Because symbolic math libraries already exist, writing this software is a relatively trivial task.
This was originally done in Mathematica because of its advanced symbolic math capabilities.
However, this required students to purchase and install Mathematica.
Because of the size and cost of Mathematica a more economical solution was desired.
To solve this problem the Python programming language along with SymPy [@meurer2017], a symbolic math library, was used to recreate the software.
This provides the same functionality without the cost barrier and with a smaller installed size.
The Python implementation also allows this code to be run as an Amazon AWS Lambda function.
With the Lambda function, a website was designed to allow this software to be used with any device which has an internet connection and a web browser.
Because equations are entered in BASIC notation, similar to most scientific calculators, no programming knowledge is needed to use this interface.

# Mathematica Package

The Mathematica package `StateMint` can be installed via the [documentation](https://github.com/CameronDevine/Statum/blob/master/mathematica/README.md). The central function of the package is `stateEquations`, which uses an algorithm similar to that of the Python package, above, to derive the state equations. It takes as arguments lists of elemental equations, constraint equations, primary variables, and input variables and returns the vector state equation, state variables, and the time-derivative of the state variables.

The `outputEquations` function derives the output equations given output expressions in terms of primary and secondary variables (including inputs). The function accepts lists of input variables, state variables, elemental and constraint equations, and output expressions.

The functions `stateEquations` and `outputEquations` yield what are in general *nonlinear* state and output equations. Linear state and output equations are typically written in a standard vector form described by matrices `A`, `B`, `C`, and `D` (and sometimes `E` and `F`). The `linearizeState` function accepts lists of input variables, state variables, and the time-derivatives of the state vector (from `stateEquations`) and returns the `A`, `B`, and `E` matrices. Similarly, `linearizeOutput` returns the `C`, `D`, and `F` matrices.

An example of how to use this package is [included](https://github.com/CameronDevine/Statum/blob/master/mathematica/Example.nb).

# Python Package

The Python package for performing the same task uses similar logic to the second method of the Mathematica package, again in the form defined by Rowell and Wormley [@rowell1997].
This function returns an object which includes the resulting system as a state space model, a transfer function, and an equation.
Helper functions are included to convert the symbolic matrices to Numpy [@oliphant2015] objects.
This code is documented using [readthedocs.io](https://statum.readthedocs.io/en/latest/) and works for both linear and nonlinear systems.

# Web Interface

To allow those without programming experience to use this code a web interface was designed and [implemented](http://statum.camerondevine.me/).
This interface has text boxes for equation input, and displays results as rendered math or code which can be copied into \LaTeX, Matlab, Python, or Mathematica.
Examples and documentation are built in to make learning how to use the interface as painless as possible.
There is also the ability to share, download, and save the system models for later use or modification.
This interface is designed to run on Amazon AWS serverless resources to simplify upkeep and keep costs low.
An automated installer is also included.

# Acknowledgments

The authors would like to acknowledge the work of [Gavin Basuel](https://www.gavinbasuel.com/) who designed the user experience for the web interface and helped with HTML/CSS development.

# References

<!--stackedit_data:
eyJkaXNjdXNzaW9ucyI6eyJTUjhYckl2em11VWpGY1paIjp7In
N0YXJ0Ijo2NjIsImVuZCI6ODE3LCJ0ZXh0IjoiV2hlbiBkZXRl
cm1pbmluZyB0aGUgZGlmZmVyZW50aWFsIGVxdWF0aW9uIG9mIG
EgZHluYW1pYyBzeXN0ZW0gdXNpbmcgbGluZWFyIGdyYeKApiJ9
LCJleVB3U3hGS1pTN3ViaWxuIjp7InN0YXJ0IjoxMTM0LCJlbm
QiOjExMzQsInRleHQiOiJXaGVuIGxlYXJuaW5nIHN5c3RlbSBk
eW5hbWljcywgc3R1ZGVudHMgd29yayBtYW55IHByb2JsZW1zIG
FzIGEgcGFydCBvZiB0aGVpciBj4oCmIn0sImtJdEwxUVZCSEl5
a21UQnQiOnsic3RhcnQiOjEyODksImVuZCI6MTQ2MCwidGV4dC
I6IlRvIGFpZCBzdHVkZW50cyBpbiB0aGVpciBsZWFybmluZyBw
cm9jZXNzIGEgcHJvZ3JhbSB3YXMgd3JpdHRlbiB0byBzeW1ib2
xpY2FsbHnigKYifSwiSDVBV2V4YUM4emxYYjIxTyI6eyJzdGFy
dCI6MTY2OSwiZW5kIjoxNzY3LCJ0ZXh0IjoiQmVjYXVzZSBzeW
1ib2xpYyBtYXRoIGxpYnJhcmllcyBhbHJlYWR5IGV4aXN0LCB3
cml0aW5nIHRoaXMgc29mdHdhcmUgaXMgYSByZWxhdOKApiJ9LC
J3RUc2Vnc4a1F3WnBoVzYzIjp7InN0YXJ0IjoxNzg4LCJlbmQi
OjE3OTIsInRleHQiOiJkb25lIn0sIlF3TER2M0gzQk1QTFVMNT
AiOnsic3RhcnQiOjE4NzQsImVuZCI6MTg4MiwidGV4dCI6InJl
cXVpcmVkIn0sInBSS1Rpbm9LZ3NXN1Z0MkgiOnsic3RhcnQiOj
E5NDQsImVuZCI6MTk1NywidGV4dCI6InNpemUgYW5kIGNvc3Qi
fSwicngyTHVtZGNLVkVpMmZVSyI6eyJzdGFydCI6MjEyOCwiZW
5kIjoyMTMyLCJ0ZXh0IjoidXNlZCJ9LCI4VkdsOUNZcmpYUE5l
NEc0Ijp7InN0YXJ0IjoyNDg2LCJlbmQiOjI0OTgsInRleHQiOi
J3ZWIgYnJvd3Nlci4ifSwiU0NubnAyVGNBWjZlZElUQyI6eyJz
dGFydCI6MjY0NywiZW5kIjoyNjY4LCJ0ZXh0IjoiIyBNYXRoZW
1hdGljYSBQYWNrYWdlIn0sIkVVUk9GNGFGN0JCN3Q4REoiOnsi
c3RhcnQiOjI3MzEsImVuZCI6MjgyMSwidGV4dCI6Iltkb2N1bW
VudGF0aW9uXSgpIn19LCJjb21tZW50cyI6eyJSeUxqazJxTGNy
OERzOEpkIjp7ImRpc2N1c3Npb25JZCI6IlNSOFhySXZ6bXVVak
ZjWloiLCJzdWIiOiJnbzoxMDI5MDU0MzU1MzA4OTY0NzQ4MDAi
LCJ0ZXh0IjoiSSdtIGEgYmlnIGJlbGlldmVyIHRoYXQgeW91ci
BmaXJzdCBzZW50ZW5jZSBzaG91bGQgdHJ5IHRvIGNvbnZleSB0
aGUgbWFpbiBwb2ludCBvZiB5b3VyIHBhcGVyLiBUaGlzIGlzIG
1vcmUgb2YgYW4gXCJpbnRyb2R1Y3Rpb25cIiBzZWN0aW9uIHNl
bnRlbmNlLCBhcyBhcmUgdGhvc2UgdGhhdCBmb2xsb3cgaXQuIF
BlcmhhcHMgdGhpcyAqaXMqIGVmZmVjdGl2ZWx5IHRoZSBpbnRy
b2R1Y3Rpb24gYW5kIHRoZXJlJ3MgYSBzZXBhcmF0ZSBhYnN0cm
FjdCAuLi4gaWYgc28sIHRoYXQncyBmaW5lLiIsImNyZWF0ZWQi
OjE1NDM3MTkxMDI4MzB9LCJ6ZGh3Y01aaWVEV3JJcGtDIjp7Im
Rpc2N1c3Npb25JZCI6IlNSOFhySXZ6bXVVakZjWloiLCJzdWIi
OiJnbzoxMDI5MDU0MzU1MzA4OTY0NzQ4MDAiLCJ0ZXh0IjoiSS
dtIGdvaW5nIHRvIGNvbnRpbnVlIGNvbW1lbnRpbmcgYXMgaWYg
dGhpcyB0ZXh0IGlzIHByZWNlZGVkIGJ5IGFuIGFic3RyYWN0IG
9mIHNvbWUgc29ydC4iLCJjcmVhdGVkIjoxNTQzNzE5MjAxODA4
fSwidWJkcU5oV1NtdEdVa1NXZSI6eyJkaXNjdXNzaW9uSWQiOi
JleVB3U3hGS1pTN3ViaWxuIiwic3ViIjoiZ286MTAyOTA1NDM1
NTMwODk2NDc0ODAwIiwidGV4dCI6IkkgdGhpbmsgYWRkaW5nIG
EgcGhyYXNlIHRvIHRoZSBwcmVjZWRpbmcgc2VudGVuY2UgY291
bGQgY2FwdHVyZSB3aGF0IHlvdSdyZSB0cnlpbmcgdG8gc2F5LC
BoZXJlLiBTb21ldGhpbmcgbGlrZSBcIi4uLiBtYWtlIG1pc3Rh
a2VzLCB3aGljaCBsZWFkIHRvIGZydXN0cmF0aW9uIGFuZCBkaX
Njb3VyYWdlbWVudCB3aGVuIG1hbnVhbGx5IHJlZHVjaW5nIHRo
ZSBzeXN0ZW0gb2YgZXF1YXRpb25zLlwiIiwiY3JlYXRlZCI6MT
U0MzcxOTYxMDY4N30sIjRCcmNOanNEbHhTYkxsTTYiOnsiZGlz
Y3Vzc2lvbklkIjoia0l0TDFRVkJISXlrbVRCdCIsInN1YiI6Im
dvOjEwMjkwNTQzNTUzMDg5NjQ3NDgwMCIsInRleHQiOiJXZSBj
YW4gbm93IGJlIG1vcmUgc3BlY2lmaWMsIGhlcmUuIFdlIGhhdm
UgYWxyZWFkeSBpbnRyb2R1Y2VkIHRoZSBlcXVhdGlvbnMgYW5k
IHRoZSB0YXNrIG9mIGF1dG9tYXRpb24uIiwiY3JlYXRlZCI6MT
U0MzcyMDA2MzY5Mn0sIkpybWRDcXJJSFBXNm5RY1UiOnsiZGlz
Y3Vzc2lvbklkIjoiSDVBV2V4YUM4emxYYjIxTyIsInN1YiI6Im
dvOjEwMjkwNTQzNTUzMDg5NjQ3NDgwMCIsInRleHQiOiJDb25z
aWRlciBnZXR0aW5nIHJpZCBvZiB0aGUgZXhpc3RlbmNlIHN0YX
RlbWVudCBhbmQgaW5zdGVhZCBmb2N1cyBvbiB0aGUgZmFjdCB0
aGF0IHdlICphcHBsaWVkIGV4aXN0aW5nKiBzeW1ib2xpYyBtYX
RoIGxpYnJhcmllcy4gQWxzbyBjb25zaWRlciBjYWxsaW5nIGl0
IFwibWF0aGVtYXRpY3NcIiBiZWNhdXNlIHdlJ3JlIGZhbmN5Ii
wiY3JlYXRlZCI6MTU0MzcyMDI3NTY1OX0sIko2RzZvODRjSHRX
QTV0WlAiOnsiZGlzY3Vzc2lvbklkIjoid0VHNlZ3OGtRd1pwaF
c2MyIsInN1YiI6ImdvOjEwMjkwNTQzNTUzMDg5NjQ3NDgwMCIs
InRleHQiOiJDb25zaWRlciByZXBocmFzaW5nIHRvIGF2b2lkIF
wiZG9uZVwiIiwiY3JlYXRlZCI6MTU0MzcyMDMwNDkzMX0sInR3
WmZ5RnhIVms0ZnZpbUQiOnsiZGlzY3Vzc2lvbklkIjoiUXdMRH
YzSDNCTVBMVUw1MCIsInN1YiI6ImdvOjEwMjkwNTQzNTUzMDg5
NjQ3NDgwMCIsInRleHQiOiJJIHRoaW5rIHByZXNlbnQgdGVuc2
UgaXMgYmV0dGVyIHNpbmNlIHdlJ3JlIHN0aWxsIHJlbGVhc2lu
ZyBhIE1NQSBwYWNrYWdlIiwiY3JlYXRlZCI6MTU0MzcyMDMzMz
U0OH0sImtuWklSeWw3UnJFWFVUMzYiOnsiZGlzY3Vzc2lvbklk
IjoicFJLVGlub0tnc1c3VnQySCIsInN1YiI6ImdvOjEwMjkwNT
QzNTUzMDg5NjQ3NDgwMCIsInRleHQiOiJJIHRoaW5rIHBlcmhh
cHMgdGhlIG1vc3QgaW1wb3J0YW50IGFzcGVjdCBpcyB0aGF0IG
l0IHJlcXVpcmVzIHN0dWRlbnRzIHRvIGxlYXJuIGEgbmV3IHNv
ZnR3YXJlIHN5c3RlbSAuLi4gd2hpY2ggbW9yZSB0aGFuIG91dH
dlaWdocyB0aGUgYWR2YW50YWdlcyBmb3IgbW9zdCBvZiB0aGUg
c3R1ZGVudHMgLi4uIHlvdXIgd2ViIGFwcCBsZXRzIHRoZW0gZ2
V0IHN0YXJ0ZWQgd2l0aG91dCBsZWFybmluZyBNTUEiLCJjcmVh
dGVkIjoxNTQzNzIwNDQ1Njc4fSwiNG94clJzaEZJaWNNMkVPTy
I6eyJkaXNjdXNzaW9uSWQiOiJyeDJMdW1kY0tWRWkyZlVLIiwi
c3ViIjoiZ286MTAyOTA1NDM1NTMwODk2NDc0ODAwIiwidGV4dC
I6Ikl0J3MgYmVzdCB0byBhdm9pZCBcInVzZWRcIiAuLi4gYW5k
IGV2ZW4gYmV0dGVyIHRvIGF2b2lkIHRoZSBwaHJhc2luZyB0aG
F0IGxlYWQgdG8gaXQuIEUuZy4gdGhpcyBzZW50ZW5jZSBjb3Vs
ZCBiZSBcIkZvciB0aGVzZSByZWFzb25zLCBhIHZlcnNpb24gb2
YgdGhlIHNvZnR3YXJlIHdyaXR0ZW4gaW4gdGhlIFB5dGhvbiAu
Li4uXCIiLCJjcmVhdGVkIjoxNTQzNzIwNjY1OTA2fSwiNG9TWV
hHMEJDc3lIcXRBaiI6eyJkaXNjdXNzaW9uSWQiOiI4VkdsOUNZ
cmpYUE5lNEc0Iiwic3ViIjoiZ286MTAyOTA1NDM1NTMwODk2ND
c0ODAwIiwidGV4dCI6IllvdSBjYW4gbm93IGRyaXZlIGhvbWUg
dGhhdCB0aGUgd2ViIGFwcCBkb2Vzbid0IHJlcXVpcmUgYW55IE
1hdGhlbWF0aWNhIG9yIFB5dGhvbi9TeW1QeSBrbm93bGVkZ2Us
IHdoaWNoIEkgdGhpbmsgaXMgdGhlIG1vc3QgaW1wb3J0YW50IG
FkdmFudGFnZSEiLCJjcmVhdGVkIjoxNTQzNzIwNzk1NjYwfSwi
NGN4aUFGZkNhclNmNjV2aiI6eyJkaXNjdXNzaW9uSWQiOiJTQ2
5ucDJUY0FaNmVkSVRDIiwic3ViIjoiZ286MTAyOTA1NDM1NTMw
ODk2NDc0ODAwIiwidGV4dCI6IkNvbnNpZGVyIHJlb3JkZXJpbm
cgdGhlc2UgLi4uIGF0IGxlYXN0IHB1dHRpbmcgTU1BIGxhc3Qs
IHNpbmNlIEkgdGhpbmsgaXQncyBsZWFzdCBpbXBvcnRhbnQuIi
wiY3JlYXRlZCI6MTU0MzcyMjUzMTY3N30sIkV1aURhWGs5blhl
ZW1HalIiOnsiZGlzY3Vzc2lvbklkIjoiRVVST0Y0YUY3QkI3dD
hESiIsInN1YiI6ImdvOjEwMjkwNTQzNTUzMDg5NjQ3NDgwMCIs
InRleHQiOiJJJ20gYWZyYWlkIHRvIGhhcmRjb2RlIHRoZSB1cm
wsIGVzcGVjaWFsbHkgaWYgd2UncmUgY2hhbmdpbmcgdG8gU3Rh
dGVNaW50IC4uLiIsImNyZWF0ZWQiOjE1NDM3NzY4MjAyMTV9LC
I2Qk40YzVtd3JVaUZnYkVCIjp7ImRpc2N1c3Npb25JZCI6IkVV
Uk9GNGFGN0JCN3Q4REoiLCJzdWIiOiJnaDoxMDM5NDg5NiIsIn
RleHQiOiJXaGVuIEkgY2hhbmdlZCB0aGUgbmFtZSBsYXN0IHRp
bWUgSSBkaWQgYSB0ZXh0IHNlYXJjaCBpbiBhbGwgZmlsZXMgZm
9yIFN0YXRlTW9kZWxSbkQuIFdoZW4gSSBjaGFuZ2UgdG8gU3Rh
dGVNaW50IEkgY2FuIHNpbXBseSBzZWFyY2ggZm9yIGFueSBmaW
xlcyB3aGljaCBpbmNsdWRlIGVpdGhlciBTdGF0ZU1vZGVsUm5E
IG9yIFN0YXR1bSBhbmQgY2hhbmdlIHRob3NlLiIsImNyZWF0ZW
QiOjE1NDM4ODIwMTM4MzB9LCI4aTJhc0Y1M2pKRlRZTDd4Ijp7
ImRpc2N1c3Npb25JZCI6IlNDbm5wMlRjQVo2ZWRJVEMiLCJzdW
IiOiJnaDoxMDM5NDg5NiIsInRleHQiOiJJIHRoaW5rIEkgb3Jp
Z2luYWxseSBvcmRlcmVkIHRoZSBzZWN0aW9ucyB0aGlzIHdheS
BiZWNhdXNlIHRoZSBNYXRoZW1hdGljYSB2ZXJzaW9uIHdhcyB3
cml0dGVuIGZpcnN0LiBJdCBtYWtlcyBzZW5zZSB0aGF0IHRoZS
B2ZXJzaW9uIHRoYXQgaXMgbW9zdCBsaWtlbHkgdG8gYmUgdXNl
ZCBzaG91bGQgYmUgcHV0IGZpcnN0LiBTbyBzaG91bGQgSSBjaG
FuZ2UgdGhlIG9yZGVyIHRvIDEuIFdlYiBJbnRlcmZhY2UsIDIu
IFB5dGhvbiwgYW5kIDMuIE1hdGhlbWF0aWNhPyIsImNyZWF0ZW
QiOjE1NDM4ODIxNjMwMjN9LCJNbHpyNFB3ZTNTbkp4N0hZIjp7
ImRpc2N1c3Npb25JZCI6IjhWR2w5Q1lyalhQTmU0RzQiLCJzdW
IiOiJnaDoxMDM5NDg5NiIsInRleHQiOiJIb3cgZG9lcyB0aGUg
cGFyYWdyYXBoIGxvb2sgbm93PyIsImNyZWF0ZWQiOjE1NDM4OD
I3NTMxMTl9LCJrN1FPWEVNSlBCR3FITWhMIjp7ImRpc2N1c3Np
b25JZCI6IjhWR2w5Q1lyalhQTmU0RzQiLCJzdWIiOiJnaDoxMD
M5NDg5NiIsInRleHQiOiJTaG91bGQgd2UgY2l0ZSBCQVNJQyBu
b3RhdGlvbiBzb21laG93LCBJIGZvdW5kIGl0IGhlcmUsICBbaH
R0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FsY3VsYXRv
cl9pbnB1dF9tZXRob2RzI0JBU0lDX25vdGF0aW9uXShodHRwcz
ovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWxjdWxhdG9yX2lu
cHV0X21ldGhvZHMjQkFTSUNfbm90YXRpb24pXG5cblJFUExZIi
wiY3JlYXRlZCI6MTU0Mzg4Mjg1ODMyNX19LCJoaXN0b3J5Ijpb
LTcwNzI0MTgxLC0xNDUxNzc5NDIzLC0xMDA5OTU4MDI3LDQ4ND
I0ODIxOCwxMTMyMjIzODkzLC01NjAzODcyNTUsLTMzMjYyMTcw
NiwxNjgyNTMwNDkzLC0xNDkyOTA5NTcsNDIzNjYwMTEsLTI1Nj
k2NTgzNywtMTIwMTkxMDQ1MiwyMDk4Nzc1OTYwXX0=
-->